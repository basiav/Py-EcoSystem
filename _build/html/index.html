
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Welcome to Py-EcoSystem’s documentation! &#8212; Py-EcoSystem  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-app.main">
<span id="welcome-to-py-ecosystem-s-documentation"></span><h1>Welcome to Py-EcoSystem’s documentation!<a class="headerlink" href="#module-app.main" title="Permalink to this headline">¶</a></h1>
<p>Main program in here.</p>
<dl class="py function">
<dt class="sig sig-object py" id="app.main.create_sample_fence">
<span class="sig-prename descclassname"><span class="pre">app.main.</span></span><span class="sig-name descname"><span class="pre">create_sample_fence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.main.create_sample_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates random maze (labyrinth/fence).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.main.create_start_menu">
<span class="sig-prename descclassname"><span class="pre">app.main.</span></span><span class="sig-name descname"><span class="pre">create_start_menu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.main.create_start_menu" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and opens start menu.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.main.main">
<span class="sig-prename descclassname"><span class="pre">app.main.</span></span><span class="sig-name descname"><span class="pre">main</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.main.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Main program.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.main.start_simulation">
<span class="sig-prename descclassname"><span class="pre">app.main.</span></span><span class="sig-name descname"><span class="pre">start_simulation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.main.start_simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs simulation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.main.terminate_animal_threads">
<span class="sig-prename descclassname"><span class="pre">app.main.</span></span><span class="sig-name descname"><span class="pre">terminate_animal_threads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.main.terminate_animal_threads" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate and join all animal threads.</p>
</dd></dl>

<span class="target" id="module-app.common"></span><p>Classes, functions and import mutual for several .py project files.</p>
<dl class="py class">
<dt class="sig sig-object py" id="app.common.Animals">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">app.common.</span></span><span class="sig-name descname"><span class="pre">Animals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.common.Animals" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="app.common.Colour">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">app.common.</span></span><span class="sig-name descname"><span class="pre">Colour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.common.Colour" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="app.common.Directions">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">app.common.</span></span><span class="sig-name descname"><span class="pre">Directions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.common.Directions" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.common.check_terrain_boundaries">
<span class="sig-prename descclassname"><span class="pre">app.common.</span></span><span class="sig-name descname"><span class="pre">check_terrain_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.common.check_terrain_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether we are within terrain (map) boundaries.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.common.set_stats">
<span class="sig-prename descclassname"><span class="pre">app.common.</span></span><span class="sig-name descname"><span class="pre">set_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">animal_species</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.common.set_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Safe multi-threading memory sharing.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.common.set_terrain_value">
<span class="sig-prename descclassname"><span class="pre">app.common.</span></span><span class="sig-name descname"><span class="pre">set_terrain_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.common.set_terrain_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Safe multi-threading memory sharing.</p>
</dd></dl>

<span class="target" id="module-app.fence"></span><p>Fence (maze) generation engine and animal movement limitations due to fence placement.</p>
<dl class="py function">
<dt class="sig sig-object py" id="app.fence.add_vertex">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">add_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_idx_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_idx_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.add_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds node_idx_2 to node_idx_1’s fence-graph neighbours</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.build_vertex">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">build_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.build_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a fence wall, first checking whether: - given nodes are placed in proper proximity (they have to be
direct neighbours for the vertex to exist), - there’s no redundancy (end_node will be placed in start_node’s
neighbourhood set and start_node will not be placed in end_node’s neighbourhood set, particular node will be
added to the neighbourhood set just once)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.can_make_move">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">can_make_move</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.can_make_move" title="Permalink to this definition">¶</a></dt>
<dd><p>Decides whether an animal can make a certain move or not, considering fence placement and map boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_row</strong> – current x position of an animal</p></li>
<li><p><strong>current_column</strong> – current y position of an animal</p></li>
<li><p><strong>delta_x</strong> – x coordinate of animal’s movement vector</p></li>
<li><p><strong>delta_y</strong> – y coordinate of animal’s movement vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.check_if_wall_exists">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">check_if_wall_exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_idx_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_idx_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.check_if_wall_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a vertex exists between given two nodes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.delete_all_walls">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">delete_all_walls</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.delete_all_walls" title="Permalink to this definition">¶</a></dt>
<dd><p>Fence clean-up.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.delete_vertex">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">delete_vertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_idx_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_idx_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.delete_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes node_idx_2 from node_idx_1’s fence-graph neighbours</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.delete_wall">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">delete_wall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.delete_wall" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes vertex between the two given nodes, checks whether they are direct neighbours and the vertex exists.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.dfs_build">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">dfs_build</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.dfs_build" title="Permalink to this definition">¶</a></dt>
<dd><p>Generuje n elementów labiryntu (płotu):
1. Wyznacza maksymalną głębokość przeszukiwania w DFS (maksymalna liczba postawionych ścian płotu w jednym cyklu
wywołań rekurencyjnych DFS) - na podstawie wielkości mapy terenu (N).
2. Wyznacza losowe początki n poszczególnych elementów (‘wysp’) labiryntu, czyli źródła n pierwotnych wywołań DFS.
3. Wywołuje n razy procedurę dfs_visit, tworząc ściany n ‘wysp’ labiryntu.
4. Wyznacza po 2 losowe punkty w obrębie każdej ‘wyspy’ (każdego drzewa przeszukiwania wgłąb), pomiędzy którymi
tworzone będzie ‘rozwiązanie’ labiryntu (patrz procedura get_maze_solution).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.dfs_visit">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">dfs_visit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wall_no</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">walls_already_built</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maze_element_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.dfs_visit" title="Permalink to this definition">¶</a></dt>
<dd><p>Buduje jedną pełną ‘wyspę’ (element) labiryntu. Generowane są zbiory łamanych otwartych, których boki mogą być
względem siebie jedynie prostopadłe lub równoległe (wybór losowy). Zbiór łamanych reprezentuje ściany labiryntu,
przestrzenie wewnątrz łamanych reprezentują korytarze labiryntu.</p>
<p>Działanie:
Kolorujemy odwiedzany wierzchołek na szaro. Sprawdzamy, czy nie przekroczyliśmy limitu ścian stawianych
w jednej serii wywołań rekurencyjnych. Losujemy kierunek, w którym postawimy ścianę (góra/prawo/dół/lewo).
Sprawdzamy warunki postawienia ściany w tym kierunku - standardowe warunki DFS z jedną modyfikacją:
za wierzchołek czarny (przetworzony) uznajemy taki, z którego wychodzą 3 ściany. Gwarantuje to otwarty charakter
łamanych. Zatem wierzchołki, z których wychodzą 1 lub 2 ściany są szare, wierzchołki, z których wychodzą 3 ściany
są czarne, a wierzchołki poza labiryntem są białe.</p>
<p>W wyniku działania tej procedury powstaje zbiór korytarzy labiryntu, bardziej lub mniej ‘rozgałęzionych’.
Są to jednak łamane otwarte, zatem do każdej z nich da się wejść z zewnątrz (spoza labiryntu), ale nie istnieją
przejścia pomiędzy nimi (inne niż wyjście z korytarzy w obrębie danej łamanej poza labirynt i wejście do
sąsiadującej łamanej). Przejścia pomiędzy łamanymi tworzone są w procedurze get_maze_solution.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.fence_border">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">fence_border</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.fence_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns directions in which the given node is adjacent to the map’s border, if they exist.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_fence_node_dirs">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_fence_node_dirs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_fence_node_dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns x and y coordinates of the given node.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_fence_node_idx">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_fence_node_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_fence_node_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the node given by its’ x and y coordinates.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_first_common_parent">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_first_common_parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_idx_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_idx_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_node_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_first_common_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes two nodes and processes their DFS tree paths (parents[]). Searches for the first node that is mutual
for those two paths (any node, including the DFS source, if the two nodes are on different DFS tree branches).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_idx_1</strong> – First node.</p></li>
<li><p><strong>node_idx_2</strong> – Second node.</p></li>
<li><p><strong>start_node_idx</strong> – DFS source node. Along with the ‘parents’ array, it constitutes the DFS tree.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary of {node with a shorter ‘DFS parent’ path to the DFS source; first mutual node; length of the shorter ‘DFS parent’ path}</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_joined_nodes_path">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_joined_nodes_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_with_shorter_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_common_node_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_with_longer_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_joined_nodes_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path between any two given points within the same DFS tree (the same maze ‘element’). Merges two paths:
- the longer one (non-reversed), starting in node_with_longer_path and passing through its’ following
DFS-parent nodes (parents[]),
- the shorter one (reversed), starting in node_with_shorter_path, which is a reverse of the DFS-parent-nodes
path (children[]).
Returns a concatenation of these two paths, hence a path between: node_with_longer_path and node_with_shorter_path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node_with_shorter_path</strong> – Beginning node of the path to reverse.</p></li>
<li><p><strong>first_common_node_idx</strong> – The first node that is mutual for both paths. It can be any node, including the DFS</p></li>
</ul>
</dd>
</dl>
<p>source node.
:param node_with_longer_path: Beginning node of the the non-reversed path.
:param length: The length of the path to be created.
:return: An array in which the i-th element represents the i-th node on the path.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_maze_solution">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_maze_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_node_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_maze_solution" title="Permalink to this definition">¶</a></dt>
<dd><p>Wyznacza ‘rozwiązanie’ labiryntu, tj. przejście pomiędzy zadanymi punktami (wierzchołkami).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_node</strong> – Start of the labirynth path.</p></li>
<li><p><strong>end_node</strong> – End of the labirynth path.</p></li>
<li><p><strong>start_node_idx</strong> – DFS source for technical purposes.</p></li>
</ul>
</dd>
</dl>
<p>Założenia:
Oba punkty są wierzchołkami tego samego drzewa przeszukiwania wgłąb, choć mogą (a nawet powinny, dla efektów
wizualnych) leżeć na różnych jego gałęziach (po różnych ‘stronach’ wierzchołka-źródła DFS).</p>
<p>Działanie:
Korzystając z gotowego już drzewa przeszukiwania wgłąb (parents[]), wyznaczać będziemy ścieżkę pomiędzy zadanymi
wierchołkami.</p>
<p>1. Rozpatrujemy ścieżki od danych wierzchołków do wierzchołka-źródła DFS i znajdujemy pierwszy (idąc od liści)
wierzchołek wspólny dla obu tych ścieżek (może być nim wierzchołek-żródło DFS, jeśli zadane wierzchołki znajdują się
na innych gałęziach głównych drzewa). Wierzchołek ten wyznacza ścieżkę pomiędzy zadanymi wierzchołkami - należy
wziąć ścieżkę od jednego zadanego wierzchołka do wierzchołka wspólnego i połączyć ją ze ścieżką od drugiego zadanego
wierzchołka do wierchołka wspólnego, ale ‘odwróconą’ (zmiana kierunku krawędzi na przeciwny). Odwracamy krótszą
z ww. ścieżek, następnie ścieżki ‘łączymy’. W otrzymanej końcowej ścieżce wierzchołkiem początkowym jest ten,
który jest bardziej oddalony od punktu wspólnego, a końcowym ten, który znajduje się bliżej punktu wspólnego.</p>
<p>2. W wygenerowanym w procedurze dfs_visit zbiorze ścian kluczowe są wierchołki czarne. Każdy wierchołek czarny to
styk 3 ścian, co oznacza, że wyznacza on 2 lub 3 sąsiadujące ze sobą łamane otwarte (korytarze). Interesować
nas będzie ciąg czarnych wierchołków obecnych na otrzymanej w pkt. 1. ścieżce. Każde 2 sąsiednie czarne wierchołki
w tym ciągu, które jednocześnie nie sąsiadują ze sobą na ścieżce, wyznaczają korytarz, którym da się przejść
(wzdłuż, zawartych pomiędzy, wierzchołków szarych). ‘Przejście’ przez labirynt polegać będzie na przejściu
‘korytarzami’ ww. ścieżki, usuwając po drodze pewne krawędzie. Najpierw wybieramy wierzchołek początkowy
(pierwszy czarny) oraz umownie ‘stronę’ ściany labiryntu, wzdłuż której będziemy się poruszać (umownie lewa/prawa).
Następnie, dopóki nie przejdziemy całej ścieżki:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>wybieramy następny czarny wierzchołek</p></li>
</ol>
<p>b) oceniamy, czy da się z niego przejść wzdłuż ‘naszej’ strony ścian do następnego wierzchołka na ścieżce
- poprzez ocenę naszego położenia względem krawędzi sąsiadów wierzchołka z pkt. a). Wychodzą z niego dwie
krawędzie inne niż ta, z której przyszliśmy, w tym jedna jest następną krawędzią naszej ścieżki. Jeśli jest to
krawędź ‘lewa’, a znajdujemy się po stronie ‘lewej’, to możemy bez problemu poruszać się dalej po tej samej
stronie. Jeśli jednak jest to krawędż ‘prawa’, a znajdujemy się po stronie lewej, usuwamy poprzednią krawędź
(tę, z której przyszliśmy) i zmieniamy stronę na przeciwną, co gwarantuje nam dalsze podążanie ścieżką.
W proc. dfs_visit powstał zbiór łamanych otwartych, czyli w zasadzie ‘pseudolabirynt’, zawsze można więc przejść
do sąsiedniego korytarza cofając się do wyjścia i wchodząc wejściem do sąsiedniego, zatem teoretycznie nie
byłoby potrzeby usuwania krawędzi. Byłoby to jednak wybitnie nielabiryntowe, dlatego stosujemy przejście ścieżką
z pkt. 1. z usuwaniem krawędzi w zależności od ‘zakrętów’ drzewa przeszukiwania wgłąb.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_move_direction">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_move_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_move_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a movement direction given by the x and y vectors.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_next_black_node">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_next_black_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_next_black_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pair of the next black (DFS tree colouring) and its’ predecessor on a given node path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_node</strong> – The current node. We’re searching for its’ next black neighbour on the given path.</p></li>
<li><p><strong>previous_node</strong> – Predecessor of the current node. Needed for the purposes of the get_maze_solution function.</p></li>
<li><p><strong>nodes_path</strong> – The graph path to follow.</p></li>
<li><p><strong>i</strong> – Position on the graph path to follow.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Pair of (predecessor, next black node).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_node_colour">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_node_colour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_idx</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_node_colour" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for DFS-based function.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_node_neighbour">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_node_neighbour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neighbour_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_node_neighbour" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a neighbour of the node given by its’ coordinates (row and column) and the direction to follow,
if exists.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_opposite_wall_side">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_opposite_wall_side</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_side</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_opposite_wall_side" title="Permalink to this definition">¶</a></dt>
<dd><p>If ‘left’ return ‘right’, if ‘right’ return ‘left’</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_path_twist_direction">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_path_twist_direction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_black_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_path_twist_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Wyznacza kierunek zakrętu ‘czyhającego’ za najbliższym czarnym wierzchołkiem na przemierzanej ścieżce nodes_path.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_black_node</strong> – Rozpatrywany czarny wierzchołek.</p></li>
<li><p><strong>nodes_path</strong> – Rozpatrywana ścieżka, którą podążamy.</p></li>
<li><p><strong>i</strong> – Wskaźnik na miejsce na ścieżce, w którym aktualnie się znajdujemy (nr indeksu current_black_node w nodes_path).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_random_corner_fence_location">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_random_corner_fence_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">randint_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">randint_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_random_corner_fence_location" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomised fence-generating starting (x, y) position.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.get_surrounding_nodes">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">get_surrounding_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_coord</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.get_surrounding_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all the nodes that border node given by args: x_coord, y_coord, provided that those nodes exist.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.neighbours_relations">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">neighbours_relations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbour</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.neighbours_relations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns direction in which arg node borders with arg neighbour, if exists.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.paint_fence_white">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">paint_fence_white</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.paint_fence_white" title="Permalink to this definition">¶</a></dt>
<dd><p>DFS tree maintenance.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.reset_fence">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">reset_fence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.reset_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>Fence clean-up.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.reset_node_colours">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">reset_node_colours</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.reset_node_colours" title="Permalink to this definition">¶</a></dt>
<dd><p>Fence clean-up.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.reset_parents_and_children">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">reset_parents_and_children</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.reset_parents_and_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Fence clean-up.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="app.fence.reverse_path">
<span class="sig-prename descclassname"><span class="pre">app.fence.</span></span><span class="sig-name descname"><span class="pre">reverse_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_beginning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.fence.reverse_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes two nodes on one DFS tree branch, processes the DFS tree path between them and reverses this path.</p>
</dd></dl>

<span class="target" id="module-app.animals"></span><p>Animal maintenance - movement, increasing/decreasing energy, procreation, checking for overpopulation
eating other species.</p>
<dl class="py class">
<dt class="sig sig-object py" id="app.animals.Animal">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">app.animals.</span></span><span class="sig-name descname"><span class="pre">Animal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">identity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.animals.Animal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="app.animals.Rabbit">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">app.animals.</span></span><span class="sig-name descname"><span class="pre">Rabbit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.animals.Rabbit" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="app.animals.Rabbit.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.animals.Rabbit.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Method representing the thread’s activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object’s constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="app.animals.Wolf">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">app.animals.</span></span><span class="sig-name descname"><span class="pre">Wolf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#app.animals.Wolf" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="app.animals.Wolf.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#app.animals.Wolf.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Method representing the thread’s activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object’s constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-gui.gui_elements"></span><p>GUI homemade elements: sliders, buttons, text lines.</p>
<span class="target" id="module-gui.plot"></span><p>Program visualisation. Starting menu, general settings menu, map settings menu, simulation window.</p>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">Py-EcoSystem</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Barbara Wojtarowicz.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>